/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumberish,
  BytesLike,
  FunctionFragment,
  Result,
  Interface,
  AddressLike,
  ContractRunner,
  ContractMethod,
  Listener,
} from "ethers";
import type {
  TypedContractEvent,
  TypedDeferredTopicFilter,
  TypedEventLog,
  TypedListener,
  TypedContractMethod,
} from "./common";

export declare namespace Order {
  export type AddressesStruct = {
    account: AddressLike;
    receiver: AddressLike;
    cancellationReceiver: AddressLike;
    callbackContract: AddressLike;
    uiFeeReceiver: AddressLike;
    market: AddressLike;
    initialCollateralToken: AddressLike;
    swapPath: AddressLike[];
  };

  export type AddressesStructOutput = [
    account: string,
    receiver: string,
    cancellationReceiver: string,
    callbackContract: string,
    uiFeeReceiver: string,
    market: string,
    initialCollateralToken: string,
    swapPath: string[],
  ] & {
    account: string;
    receiver: string;
    cancellationReceiver: string;
    callbackContract: string;
    uiFeeReceiver: string;
    market: string;
    initialCollateralToken: string;
    swapPath: string[];
  };

  export type NumbersStruct = {
    orderType: BigNumberish;
    decreasePositionSwapType: BigNumberish;
    sizeDeltaUsd: BigNumberish;
    initialCollateralDeltaAmount: BigNumberish;
    triggerPrice: BigNumberish;
    acceptablePrice: BigNumberish;
    executionFee: BigNumberish;
    callbackGasLimit: BigNumberish;
    minOutputAmount: BigNumberish;
    updatedAtTime: BigNumberish;
    validFromTime: BigNumberish;
    srcChainId: BigNumberish;
  };

  export type NumbersStructOutput = [
    orderType: bigint,
    decreasePositionSwapType: bigint,
    sizeDeltaUsd: bigint,
    initialCollateralDeltaAmount: bigint,
    triggerPrice: bigint,
    acceptablePrice: bigint,
    executionFee: bigint,
    callbackGasLimit: bigint,
    minOutputAmount: bigint,
    updatedAtTime: bigint,
    validFromTime: bigint,
    srcChainId: bigint,
  ] & {
    orderType: bigint;
    decreasePositionSwapType: bigint;
    sizeDeltaUsd: bigint;
    initialCollateralDeltaAmount: bigint;
    triggerPrice: bigint;
    acceptablePrice: bigint;
    executionFee: bigint;
    callbackGasLimit: bigint;
    minOutputAmount: bigint;
    updatedAtTime: bigint;
    validFromTime: bigint;
    srcChainId: bigint;
  };

  export type FlagsStruct = {
    isLong: boolean;
    shouldUnwrapNativeToken: boolean;
    isFrozen: boolean;
    autoCancel: boolean;
  };

  export type FlagsStructOutput = [
    isLong: boolean,
    shouldUnwrapNativeToken: boolean,
    isFrozen: boolean,
    autoCancel: boolean,
  ] & {
    isLong: boolean;
    shouldUnwrapNativeToken: boolean;
    isFrozen: boolean;
    autoCancel: boolean;
  };

  export type PropsStruct = {
    addresses: Order.AddressesStruct;
    numbers: Order.NumbersStruct;
    flags: Order.FlagsStruct;
    _dataList: BytesLike[];
  };

  export type PropsStructOutput = [
    addresses: Order.AddressesStructOutput,
    numbers: Order.NumbersStructOutput,
    flags: Order.FlagsStructOutput,
    _dataList: string[],
  ] & {
    addresses: Order.AddressesStructOutput;
    numbers: Order.NumbersStructOutput;
    flags: Order.FlagsStructOutput;
    _dataList: string[];
  };
}

export declare namespace ReaderUtils {
  export type OrderInfoStruct = {
    orderKey: BytesLike;
    order: Order.PropsStruct;
  };

  export type OrderInfoStructOutput = [orderKey: string, order: Order.PropsStructOutput] & {
    orderKey: string;
    order: Order.PropsStructOutput;
  };

  export type BaseFundingValuesStruct = {
    fundingFeeAmountPerSize: MarketUtils.PositionTypeStruct;
    claimableFundingAmountPerSize: MarketUtils.PositionTypeStruct;
  };

  export type BaseFundingValuesStructOutput = [
    fundingFeeAmountPerSize: MarketUtils.PositionTypeStructOutput,
    claimableFundingAmountPerSize: MarketUtils.PositionTypeStructOutput,
  ] & {
    fundingFeeAmountPerSize: MarketUtils.PositionTypeStructOutput;
    claimableFundingAmountPerSize: MarketUtils.PositionTypeStructOutput;
  };

  export type VirtualInventoryStruct = {
    virtualPoolAmountForLongToken: BigNumberish;
    virtualPoolAmountForShortToken: BigNumberish;
    virtualInventoryForPositions: BigNumberish;
  };

  export type VirtualInventoryStructOutput = [
    virtualPoolAmountForLongToken: bigint,
    virtualPoolAmountForShortToken: bigint,
    virtualInventoryForPositions: bigint,
  ] & {
    virtualPoolAmountForLongToken: bigint;
    virtualPoolAmountForShortToken: bigint;
    virtualInventoryForPositions: bigint;
  };

  export type MarketInfoStruct = {
    market: Market.PropsStruct;
    borrowingFactorPerSecondForLongs: BigNumberish;
    borrowingFactorPerSecondForShorts: BigNumberish;
    baseFunding: ReaderUtils.BaseFundingValuesStruct;
    nextFunding: MarketUtils.GetNextFundingAmountPerSizeResultStruct;
    virtualInventory: ReaderUtils.VirtualInventoryStruct;
    isDisabled: boolean;
  };

  export type MarketInfoStructOutput = [
    market: Market.PropsStructOutput,
    borrowingFactorPerSecondForLongs: bigint,
    borrowingFactorPerSecondForShorts: bigint,
    baseFunding: ReaderUtils.BaseFundingValuesStructOutput,
    nextFunding: MarketUtils.GetNextFundingAmountPerSizeResultStructOutput,
    virtualInventory: ReaderUtils.VirtualInventoryStructOutput,
    isDisabled: boolean,
  ] & {
    market: Market.PropsStructOutput;
    borrowingFactorPerSecondForLongs: bigint;
    borrowingFactorPerSecondForShorts: bigint;
    baseFunding: ReaderUtils.BaseFundingValuesStructOutput;
    nextFunding: MarketUtils.GetNextFundingAmountPerSizeResultStructOutput;
    virtualInventory: ReaderUtils.VirtualInventoryStructOutput;
    isDisabled: boolean;
  };
}

export declare namespace Price {
  export type PropsStruct = { min: BigNumberish; max: BigNumberish };

  export type PropsStructOutput = [min: bigint, max: bigint] & {
    min: bigint;
    max: bigint;
  };
}

export declare namespace MarketUtils {
  export type MarketPricesStruct = {
    indexTokenPrice: Price.PropsStruct;
    longTokenPrice: Price.PropsStruct;
    shortTokenPrice: Price.PropsStruct;
  };

  export type MarketPricesStructOutput = [
    indexTokenPrice: Price.PropsStructOutput,
    longTokenPrice: Price.PropsStructOutput,
    shortTokenPrice: Price.PropsStructOutput,
  ] & {
    indexTokenPrice: Price.PropsStructOutput;
    longTokenPrice: Price.PropsStructOutput;
    shortTokenPrice: Price.PropsStructOutput;
  };

  export type CollateralTypeStruct = {
    longToken: BigNumberish;
    shortToken: BigNumberish;
  };

  export type CollateralTypeStructOutput = [longToken: bigint, shortToken: bigint] & {
    longToken: bigint;
    shortToken: bigint;
  };

  export type PositionTypeStruct = {
    long: MarketUtils.CollateralTypeStruct;
    short: MarketUtils.CollateralTypeStruct;
  };

  export type PositionTypeStructOutput = [
    long: MarketUtils.CollateralTypeStructOutput,
    short: MarketUtils.CollateralTypeStructOutput,
  ] & {
    long: MarketUtils.CollateralTypeStructOutput;
    short: MarketUtils.CollateralTypeStructOutput;
  };

  export type GetNextFundingAmountPerSizeResultStruct = {
    longsPayShorts: boolean;
    fundingFactorPerSecond: BigNumberish;
    nextSavedFundingFactorPerSecond: BigNumberish;
    fundingFeeAmountPerSizeDelta: MarketUtils.PositionTypeStruct;
    claimableFundingAmountPerSizeDelta: MarketUtils.PositionTypeStruct;
  };

  export type GetNextFundingAmountPerSizeResultStructOutput = [
    longsPayShorts: boolean,
    fundingFactorPerSecond: bigint,
    nextSavedFundingFactorPerSecond: bigint,
    fundingFeeAmountPerSizeDelta: MarketUtils.PositionTypeStructOutput,
    claimableFundingAmountPerSizeDelta: MarketUtils.PositionTypeStructOutput,
  ] & {
    longsPayShorts: boolean;
    fundingFactorPerSecond: bigint;
    nextSavedFundingFactorPerSecond: bigint;
    fundingFeeAmountPerSizeDelta: MarketUtils.PositionTypeStructOutput;
    claimableFundingAmountPerSizeDelta: MarketUtils.PositionTypeStructOutput;
  };
}

export declare namespace Position {
  export type AddressesStruct = {
    account: AddressLike;
    market: AddressLike;
    collateralToken: AddressLike;
  };

  export type AddressesStructOutput = [account: string, market: string, collateralToken: string] & {
    account: string;
    market: string;
    collateralToken: string;
  };

  export type NumbersStruct = {
    sizeInUsd: BigNumberish;
    sizeInTokens: BigNumberish;
    collateralAmount: BigNumberish;
    pendingImpactAmount: BigNumberish;
    borrowingFactor: BigNumberish;
    fundingFeeAmountPerSize: BigNumberish;
    longTokenClaimableFundingAmountPerSize: BigNumberish;
    shortTokenClaimableFundingAmountPerSize: BigNumberish;
    increasedAtTime: BigNumberish;
    decreasedAtTime: BigNumberish;
  };

  export type NumbersStructOutput = [
    sizeInUsd: bigint,
    sizeInTokens: bigint,
    collateralAmount: bigint,
    pendingImpactAmount: bigint,
    borrowingFactor: bigint,
    fundingFeeAmountPerSize: bigint,
    longTokenClaimableFundingAmountPerSize: bigint,
    shortTokenClaimableFundingAmountPerSize: bigint,
    increasedAtTime: bigint,
    decreasedAtTime: bigint,
  ] & {
    sizeInUsd: bigint;
    sizeInTokens: bigint;
    collateralAmount: bigint;
    pendingImpactAmount: bigint;
    borrowingFactor: bigint;
    fundingFeeAmountPerSize: bigint;
    longTokenClaimableFundingAmountPerSize: bigint;
    shortTokenClaimableFundingAmountPerSize: bigint;
    increasedAtTime: bigint;
    decreasedAtTime: bigint;
  };

  export type FlagsStruct = { isLong: boolean };

  export type FlagsStructOutput = [isLong: boolean] & { isLong: boolean };

  export type PropsStruct = {
    addresses: Position.AddressesStruct;
    numbers: Position.NumbersStruct;
    flags: Position.FlagsStruct;
  };

  export type PropsStructOutput = [
    addresses: Position.AddressesStructOutput,
    numbers: Position.NumbersStructOutput,
    flags: Position.FlagsStructOutput,
  ] & {
    addresses: Position.AddressesStructOutput;
    numbers: Position.NumbersStructOutput;
    flags: Position.FlagsStructOutput;
  };
}

export declare namespace PositionPricingUtils {
  export type PositionReferralFeesStruct = {
    referralCode: BytesLike;
    affiliate: AddressLike;
    trader: AddressLike;
    totalRebateFactor: BigNumberish;
    affiliateRewardFactor: BigNumberish;
    adjustedAffiliateRewardFactor: BigNumberish;
    traderDiscountFactor: BigNumberish;
    totalRebateAmount: BigNumberish;
    traderDiscountAmount: BigNumberish;
    affiliateRewardAmount: BigNumberish;
  };

  export type PositionReferralFeesStructOutput = [
    referralCode: string,
    affiliate: string,
    trader: string,
    totalRebateFactor: bigint,
    affiliateRewardFactor: bigint,
    adjustedAffiliateRewardFactor: bigint,
    traderDiscountFactor: bigint,
    totalRebateAmount: bigint,
    traderDiscountAmount: bigint,
    affiliateRewardAmount: bigint,
  ] & {
    referralCode: string;
    affiliate: string;
    trader: string;
    totalRebateFactor: bigint;
    affiliateRewardFactor: bigint;
    adjustedAffiliateRewardFactor: bigint;
    traderDiscountFactor: bigint;
    totalRebateAmount: bigint;
    traderDiscountAmount: bigint;
    affiliateRewardAmount: bigint;
  };

  export type PositionProFeesStruct = {
    traderTier: BigNumberish;
    traderDiscountFactor: BigNumberish;
    traderDiscountAmount: BigNumberish;
  };

  export type PositionProFeesStructOutput = [
    traderTier: bigint,
    traderDiscountFactor: bigint,
    traderDiscountAmount: bigint,
  ] & {
    traderTier: bigint;
    traderDiscountFactor: bigint;
    traderDiscountAmount: bigint;
  };

  export type PositionFundingFeesStruct = {
    fundingFeeAmount: BigNumberish;
    claimableLongTokenAmount: BigNumberish;
    claimableShortTokenAmount: BigNumberish;
    latestFundingFeeAmountPerSize: BigNumberish;
    latestLongTokenClaimableFundingAmountPerSize: BigNumberish;
    latestShortTokenClaimableFundingAmountPerSize: BigNumberish;
  };

  export type PositionFundingFeesStructOutput = [
    fundingFeeAmount: bigint,
    claimableLongTokenAmount: bigint,
    claimableShortTokenAmount: bigint,
    latestFundingFeeAmountPerSize: bigint,
    latestLongTokenClaimableFundingAmountPerSize: bigint,
    latestShortTokenClaimableFundingAmountPerSize: bigint,
  ] & {
    fundingFeeAmount: bigint;
    claimableLongTokenAmount: bigint;
    claimableShortTokenAmount: bigint;
    latestFundingFeeAmountPerSize: bigint;
    latestLongTokenClaimableFundingAmountPerSize: bigint;
    latestShortTokenClaimableFundingAmountPerSize: bigint;
  };

  export type PositionBorrowingFeesStruct = {
    borrowingFeeUsd: BigNumberish;
    borrowingFeeAmount: BigNumberish;
    borrowingFeeReceiverFactor: BigNumberish;
    borrowingFeeAmountForFeeReceiver: BigNumberish;
  };

  export type PositionBorrowingFeesStructOutput = [
    borrowingFeeUsd: bigint,
    borrowingFeeAmount: bigint,
    borrowingFeeReceiverFactor: bigint,
    borrowingFeeAmountForFeeReceiver: bigint,
  ] & {
    borrowingFeeUsd: bigint;
    borrowingFeeAmount: bigint;
    borrowingFeeReceiverFactor: bigint;
    borrowingFeeAmountForFeeReceiver: bigint;
  };

  export type PositionUiFeesStruct = {
    uiFeeReceiver: AddressLike;
    uiFeeReceiverFactor: BigNumberish;
    uiFeeAmount: BigNumberish;
  };

  export type PositionUiFeesStructOutput = [uiFeeReceiver: string, uiFeeReceiverFactor: bigint, uiFeeAmount: bigint] & {
    uiFeeReceiver: string;
    uiFeeReceiverFactor: bigint;
    uiFeeAmount: bigint;
  };

  export type PositionLiquidationFeesStruct = {
    liquidationFeeUsd: BigNumberish;
    liquidationFeeAmount: BigNumberish;
    liquidationFeeReceiverFactor: BigNumberish;
    liquidationFeeAmountForFeeReceiver: BigNumberish;
  };

  export type PositionLiquidationFeesStructOutput = [
    liquidationFeeUsd: bigint,
    liquidationFeeAmount: bigint,
    liquidationFeeReceiverFactor: bigint,
    liquidationFeeAmountForFeeReceiver: bigint,
  ] & {
    liquidationFeeUsd: bigint;
    liquidationFeeAmount: bigint;
    liquidationFeeReceiverFactor: bigint;
    liquidationFeeAmountForFeeReceiver: bigint;
  };

  export type PositionFeesStruct = {
    referral: PositionPricingUtils.PositionReferralFeesStruct;
    pro: PositionPricingUtils.PositionProFeesStruct;
    funding: PositionPricingUtils.PositionFundingFeesStruct;
    borrowing: PositionPricingUtils.PositionBorrowingFeesStruct;
    ui: PositionPricingUtils.PositionUiFeesStruct;
    liquidation: PositionPricingUtils.PositionLiquidationFeesStruct;
    collateralTokenPrice: Price.PropsStruct;
    positionFeeFactor: BigNumberish;
    protocolFeeAmount: BigNumberish;
    positionFeeReceiverFactor: BigNumberish;
    feeReceiverAmount: BigNumberish;
    feeAmountForPool: BigNumberish;
    positionFeeAmountForPool: BigNumberish;
    positionFeeAmount: BigNumberish;
    totalCostAmountExcludingFunding: BigNumberish;
    totalCostAmount: BigNumberish;
    totalDiscountAmount: BigNumberish;
  };

  export type PositionFeesStructOutput = [
    referral: PositionPricingUtils.PositionReferralFeesStructOutput,
    pro: PositionPricingUtils.PositionProFeesStructOutput,
    funding: PositionPricingUtils.PositionFundingFeesStructOutput,
    borrowing: PositionPricingUtils.PositionBorrowingFeesStructOutput,
    ui: PositionPricingUtils.PositionUiFeesStructOutput,
    liquidation: PositionPricingUtils.PositionLiquidationFeesStructOutput,
    collateralTokenPrice: Price.PropsStructOutput,
    positionFeeFactor: bigint,
    protocolFeeAmount: bigint,
    positionFeeReceiverFactor: bigint,
    feeReceiverAmount: bigint,
    feeAmountForPool: bigint,
    positionFeeAmountForPool: bigint,
    positionFeeAmount: bigint,
    totalCostAmountExcludingFunding: bigint,
    totalCostAmount: bigint,
    totalDiscountAmount: bigint,
  ] & {
    referral: PositionPricingUtils.PositionReferralFeesStructOutput;
    pro: PositionPricingUtils.PositionProFeesStructOutput;
    funding: PositionPricingUtils.PositionFundingFeesStructOutput;
    borrowing: PositionPricingUtils.PositionBorrowingFeesStructOutput;
    ui: PositionPricingUtils.PositionUiFeesStructOutput;
    liquidation: PositionPricingUtils.PositionLiquidationFeesStructOutput;
    collateralTokenPrice: Price.PropsStructOutput;
    positionFeeFactor: bigint;
    protocolFeeAmount: bigint;
    positionFeeReceiverFactor: bigint;
    feeReceiverAmount: bigint;
    feeAmountForPool: bigint;
    positionFeeAmountForPool: bigint;
    positionFeeAmount: bigint;
    totalCostAmountExcludingFunding: bigint;
    totalCostAmount: bigint;
    totalDiscountAmount: bigint;
  };
}

export declare namespace ReaderPricingUtils {
  export type ExecutionPriceResultStruct = {
    priceImpactUsd: BigNumberish;
    executionPrice: BigNumberish;
    balanceWasImproved: boolean;
    proportionalPendingImpactUsd: BigNumberish;
    totalImpactUsd: BigNumberish;
    priceImpactDiffUsd: BigNumberish;
  };

  export type ExecutionPriceResultStructOutput = [
    priceImpactUsd: bigint,
    executionPrice: bigint,
    balanceWasImproved: boolean,
    proportionalPendingImpactUsd: bigint,
    totalImpactUsd: bigint,
    priceImpactDiffUsd: bigint,
  ] & {
    priceImpactUsd: bigint;
    executionPrice: bigint;
    balanceWasImproved: boolean;
    proportionalPendingImpactUsd: bigint;
    totalImpactUsd: bigint;
    priceImpactDiffUsd: bigint;
  };
}

export declare namespace ReaderPositionUtils {
  export type PositionInfoStruct = {
    positionKey: BytesLike;
    position: Position.PropsStruct;
    fees: PositionPricingUtils.PositionFeesStruct;
    executionPriceResult: ReaderPricingUtils.ExecutionPriceResultStruct;
    basePnlUsd: BigNumberish;
    uncappedBasePnlUsd: BigNumberish;
    pnlAfterPriceImpactUsd: BigNumberish;
  };

  export type PositionInfoStructOutput = [
    positionKey: string,
    position: Position.PropsStructOutput,
    fees: PositionPricingUtils.PositionFeesStructOutput,
    executionPriceResult: ReaderPricingUtils.ExecutionPriceResultStructOutput,
    basePnlUsd: bigint,
    uncappedBasePnlUsd: bigint,
    pnlAfterPriceImpactUsd: bigint,
  ] & {
    positionKey: string;
    position: Position.PropsStructOutput;
    fees: PositionPricingUtils.PositionFeesStructOutput;
    executionPriceResult: ReaderPricingUtils.ExecutionPriceResultStructOutput;
    basePnlUsd: bigint;
    uncappedBasePnlUsd: bigint;
    pnlAfterPriceImpactUsd: bigint;
  };
}

export declare namespace Deposit {
  export type AddressesStruct = {
    account: AddressLike;
    receiver: AddressLike;
    callbackContract: AddressLike;
    uiFeeReceiver: AddressLike;
    market: AddressLike;
    initialLongToken: AddressLike;
    initialShortToken: AddressLike;
    longTokenSwapPath: AddressLike[];
    shortTokenSwapPath: AddressLike[];
  };

  export type AddressesStructOutput = [
    account: string,
    receiver: string,
    callbackContract: string,
    uiFeeReceiver: string,
    market: string,
    initialLongToken: string,
    initialShortToken: string,
    longTokenSwapPath: string[],
    shortTokenSwapPath: string[],
  ] & {
    account: string;
    receiver: string;
    callbackContract: string;
    uiFeeReceiver: string;
    market: string;
    initialLongToken: string;
    initialShortToken: string;
    longTokenSwapPath: string[];
    shortTokenSwapPath: string[];
  };

  export type NumbersStruct = {
    initialLongTokenAmount: BigNumberish;
    initialShortTokenAmount: BigNumberish;
    minMarketTokens: BigNumberish;
    updatedAtTime: BigNumberish;
    executionFee: BigNumberish;
    callbackGasLimit: BigNumberish;
    srcChainId: BigNumberish;
  };

  export type NumbersStructOutput = [
    initialLongTokenAmount: bigint,
    initialShortTokenAmount: bigint,
    minMarketTokens: bigint,
    updatedAtTime: bigint,
    executionFee: bigint,
    callbackGasLimit: bigint,
    srcChainId: bigint,
  ] & {
    initialLongTokenAmount: bigint;
    initialShortTokenAmount: bigint;
    minMarketTokens: bigint;
    updatedAtTime: bigint;
    executionFee: bigint;
    callbackGasLimit: bigint;
    srcChainId: bigint;
  };

  export type FlagsStruct = { shouldUnwrapNativeToken: boolean };

  export type FlagsStructOutput = [shouldUnwrapNativeToken: boolean] & {
    shouldUnwrapNativeToken: boolean;
  };

  export type PropsStruct = {
    addresses: Deposit.AddressesStruct;
    numbers: Deposit.NumbersStruct;
    flags: Deposit.FlagsStruct;
    _dataList: BytesLike[];
  };

  export type PropsStructOutput = [
    addresses: Deposit.AddressesStructOutput,
    numbers: Deposit.NumbersStructOutput,
    flags: Deposit.FlagsStructOutput,
    _dataList: string[],
  ] & {
    addresses: Deposit.AddressesStructOutput;
    numbers: Deposit.NumbersStructOutput;
    flags: Deposit.FlagsStructOutput;
    _dataList: string[];
  };
}

export declare namespace Market {
  export type PropsStruct = {
    marketToken: AddressLike;
    indexToken: AddressLike;
    longToken: AddressLike;
    shortToken: AddressLike;
  };

  export type PropsStructOutput = [marketToken: string, indexToken: string, longToken: string, shortToken: string] & {
    marketToken: string;
    indexToken: string;
    longToken: string;
    shortToken: string;
  };
}

export declare namespace MarketPoolValueInfo {
  export type PropsStruct = {
    poolValue: BigNumberish;
    longPnl: BigNumberish;
    shortPnl: BigNumberish;
    netPnl: BigNumberish;
    longTokenAmount: BigNumberish;
    shortTokenAmount: BigNumberish;
    longTokenUsd: BigNumberish;
    shortTokenUsd: BigNumberish;
    totalBorrowingFees: BigNumberish;
    borrowingFeePoolFactor: BigNumberish;
    impactPoolAmount: BigNumberish;
    lentImpactPoolAmount: BigNumberish;
  };

  export type PropsStructOutput = [
    poolValue: bigint,
    longPnl: bigint,
    shortPnl: bigint,
    netPnl: bigint,
    longTokenAmount: bigint,
    shortTokenAmount: bigint,
    longTokenUsd: bigint,
    shortTokenUsd: bigint,
    totalBorrowingFees: bigint,
    borrowingFeePoolFactor: bigint,
    impactPoolAmount: bigint,
    lentImpactPoolAmount: bigint,
  ] & {
    poolValue: bigint;
    longPnl: bigint;
    shortPnl: bigint;
    netPnl: bigint;
    longTokenAmount: bigint;
    shortTokenAmount: bigint;
    longTokenUsd: bigint;
    shortTokenUsd: bigint;
    totalBorrowingFees: bigint;
    borrowingFeePoolFactor: bigint;
    impactPoolAmount: bigint;
    lentImpactPoolAmount: bigint;
  };
}

export declare namespace Shift {
  export type AddressesStruct = {
    account: AddressLike;
    receiver: AddressLike;
    callbackContract: AddressLike;
    uiFeeReceiver: AddressLike;
    fromMarket: AddressLike;
    toMarket: AddressLike;
  };

  export type AddressesStructOutput = [
    account: string,
    receiver: string,
    callbackContract: string,
    uiFeeReceiver: string,
    fromMarket: string,
    toMarket: string,
  ] & {
    account: string;
    receiver: string;
    callbackContract: string;
    uiFeeReceiver: string;
    fromMarket: string;
    toMarket: string;
  };

  export type NumbersStruct = {
    marketTokenAmount: BigNumberish;
    minMarketTokens: BigNumberish;
    updatedAtTime: BigNumberish;
    executionFee: BigNumberish;
    callbackGasLimit: BigNumberish;
    srcChainId: BigNumberish;
  };

  export type NumbersStructOutput = [
    marketTokenAmount: bigint,
    minMarketTokens: bigint,
    updatedAtTime: bigint,
    executionFee: bigint,
    callbackGasLimit: bigint,
    srcChainId: bigint,
  ] & {
    marketTokenAmount: bigint;
    minMarketTokens: bigint;
    updatedAtTime: bigint;
    executionFee: bigint;
    callbackGasLimit: bigint;
    srcChainId: bigint;
  };

  export type PropsStruct = {
    addresses: Shift.AddressesStruct;
    numbers: Shift.NumbersStruct;
    _dataList: BytesLike[];
  };

  export type PropsStructOutput = [
    addresses: Shift.AddressesStructOutput,
    numbers: Shift.NumbersStructOutput,
    _dataList: string[],
  ] & {
    addresses: Shift.AddressesStructOutput;
    numbers: Shift.NumbersStructOutput;
    _dataList: string[];
  };
}

export declare namespace SwapPricingUtils {
  export type SwapFeesStruct = {
    feeReceiverAmount: BigNumberish;
    feeAmountForPool: BigNumberish;
    amountAfterFees: BigNumberish;
    uiFeeReceiver: AddressLike;
    uiFeeReceiverFactor: BigNumberish;
    uiFeeAmount: BigNumberish;
  };

  export type SwapFeesStructOutput = [
    feeReceiverAmount: bigint,
    feeAmountForPool: bigint,
    amountAfterFees: bigint,
    uiFeeReceiver: string,
    uiFeeReceiverFactor: bigint,
    uiFeeAmount: bigint,
  ] & {
    feeReceiverAmount: bigint;
    feeAmountForPool: bigint;
    amountAfterFees: bigint;
    uiFeeReceiver: string;
    uiFeeReceiverFactor: bigint;
    uiFeeAmount: bigint;
  };
}

export declare namespace Withdrawal {
  export type AddressesStruct = {
    account: AddressLike;
    receiver: AddressLike;
    callbackContract: AddressLike;
    uiFeeReceiver: AddressLike;
    market: AddressLike;
    longTokenSwapPath: AddressLike[];
    shortTokenSwapPath: AddressLike[];
  };

  export type AddressesStructOutput = [
    account: string,
    receiver: string,
    callbackContract: string,
    uiFeeReceiver: string,
    market: string,
    longTokenSwapPath: string[],
    shortTokenSwapPath: string[],
  ] & {
    account: string;
    receiver: string;
    callbackContract: string;
    uiFeeReceiver: string;
    market: string;
    longTokenSwapPath: string[];
    shortTokenSwapPath: string[];
  };

  export type NumbersStruct = {
    marketTokenAmount: BigNumberish;
    minLongTokenAmount: BigNumberish;
    minShortTokenAmount: BigNumberish;
    updatedAtTime: BigNumberish;
    executionFee: BigNumberish;
    callbackGasLimit: BigNumberish;
    srcChainId: BigNumberish;
  };

  export type NumbersStructOutput = [
    marketTokenAmount: bigint,
    minLongTokenAmount: bigint,
    minShortTokenAmount: bigint,
    updatedAtTime: bigint,
    executionFee: bigint,
    callbackGasLimit: bigint,
    srcChainId: bigint,
  ] & {
    marketTokenAmount: bigint;
    minLongTokenAmount: bigint;
    minShortTokenAmount: bigint;
    updatedAtTime: bigint;
    executionFee: bigint;
    callbackGasLimit: bigint;
    srcChainId: bigint;
  };

  export type FlagsStruct = { shouldUnwrapNativeToken: boolean };

  export type FlagsStructOutput = [shouldUnwrapNativeToken: boolean] & {
    shouldUnwrapNativeToken: boolean;
  };

  export type PropsStruct = {
    addresses: Withdrawal.AddressesStruct;
    numbers: Withdrawal.NumbersStruct;
    flags: Withdrawal.FlagsStruct;
    _dataList: BytesLike[];
  };

  export type PropsStructOutput = [
    addresses: Withdrawal.AddressesStructOutput,
    numbers: Withdrawal.NumbersStructOutput,
    flags: Withdrawal.FlagsStructOutput,
    _dataList: string[],
  ] & {
    addresses: Withdrawal.AddressesStructOutput;
    numbers: Withdrawal.NumbersStructOutput;
    flags: Withdrawal.FlagsStructOutput;
    _dataList: string[];
  };
}

export declare namespace PositionUtils {
  export type IsPositionLiquidatableInfoStruct = {
    remainingCollateralUsd: BigNumberish;
    minCollateralUsd: BigNumberish;
    minCollateralUsdForLeverage: BigNumberish;
  };

  export type IsPositionLiquidatableInfoStructOutput = [
    remainingCollateralUsd: bigint,
    minCollateralUsd: bigint,
    minCollateralUsdForLeverage: bigint,
  ] & {
    remainingCollateralUsd: bigint;
    minCollateralUsd: bigint;
    minCollateralUsdForLeverage: bigint;
  };
}

export interface SyntheticsReaderInterface extends Interface {
  getFunction(
    nameOrSignature:
      | "getAccountOrders"
      | "getAccountPositionInfoList"
      | "getAccountPositions"
      | "getAdlState"
      | "getDeposit"
      | "getDepositAmountOut"
      | "getExecutionPrice"
      | "getMarket"
      | "getMarketBySalt"
      | "getMarketInfo"
      | "getMarketInfoList"
      | "getMarketTokenPrice"
      | "getMarkets"
      | "getNetPnl"
      | "getOpenInterestWithPnl"
      | "getOrder"
      | "getPendingPositionImpactPoolDistributionAmount"
      | "getPnl"
      | "getPnlToPoolFactor"
      | "getPosition"
      | "getPositionInfo"
      | "getPositionInfoList"
      | "getPositionPnlUsd"
      | "getShift"
      | "getSwapAmountOut"
      | "getSwapPriceImpact"
      | "getWithdrawal"
      | "getWithdrawalAmountOut"
      | "isPositionLiquidatable"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "getAccountOrders",
    values: [AddressLike, AddressLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getAccountPositionInfoList",
    values: [
      AddressLike,
      AddressLike,
      AddressLike,
      AddressLike[],
      MarketUtils.MarketPricesStruct[],
      AddressLike,
      BigNumberish,
      BigNumberish,
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getAccountPositions",
    values: [AddressLike, AddressLike, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getAdlState",
    values: [AddressLike, AddressLike, boolean, MarketUtils.MarketPricesStruct]
  ): string;
  encodeFunctionData(functionFragment: "getDeposit", values: [AddressLike, BytesLike]): string;
  encodeFunctionData(
    functionFragment: "getDepositAmountOut",
    values: [
      AddressLike,
      Market.PropsStruct,
      MarketUtils.MarketPricesStruct,
      BigNumberish,
      BigNumberish,
      AddressLike,
      BigNumberish,
      boolean,
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getExecutionPrice",
    values: [
      AddressLike,
      AddressLike,
      MarketUtils.MarketPricesStruct,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      boolean,
    ]
  ): string;
  encodeFunctionData(functionFragment: "getMarket", values: [AddressLike, AddressLike]): string;
  encodeFunctionData(functionFragment: "getMarketBySalt", values: [AddressLike, BytesLike]): string;
  encodeFunctionData(
    functionFragment: "getMarketInfo",
    values: [AddressLike, MarketUtils.MarketPricesStruct, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getMarketInfoList",
    values: [AddressLike, MarketUtils.MarketPricesStruct[], BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getMarketTokenPrice",
    values: [
      AddressLike,
      Market.PropsStruct,
      Price.PropsStruct,
      Price.PropsStruct,
      Price.PropsStruct,
      BytesLike,
      boolean,
    ]
  ): string;
  encodeFunctionData(functionFragment: "getMarkets", values: [AddressLike, BigNumberish, BigNumberish]): string;
  encodeFunctionData(
    functionFragment: "getNetPnl",
    values: [AddressLike, Market.PropsStruct, Price.PropsStruct, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "getOpenInterestWithPnl",
    values: [AddressLike, Market.PropsStruct, Price.PropsStruct, boolean, boolean]
  ): string;
  encodeFunctionData(functionFragment: "getOrder", values: [AddressLike, BytesLike]): string;
  encodeFunctionData(
    functionFragment: "getPendingPositionImpactPoolDistributionAmount",
    values: [AddressLike, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getPnl",
    values: [AddressLike, Market.PropsStruct, Price.PropsStruct, boolean, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "getPnlToPoolFactor",
    values: [AddressLike, AddressLike, MarketUtils.MarketPricesStruct, boolean, boolean]
  ): string;
  encodeFunctionData(functionFragment: "getPosition", values: [AddressLike, BytesLike]): string;
  encodeFunctionData(
    functionFragment: "getPositionInfo",
    values: [AddressLike, AddressLike, BytesLike, MarketUtils.MarketPricesStruct, BigNumberish, AddressLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "getPositionInfoList",
    values: [AddressLike, AddressLike, BytesLike[], MarketUtils.MarketPricesStruct[], AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getPositionPnlUsd",
    values: [AddressLike, Market.PropsStruct, MarketUtils.MarketPricesStruct, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "getShift", values: [AddressLike, BytesLike]): string;
  encodeFunctionData(
    functionFragment: "getSwapAmountOut",
    values: [AddressLike, Market.PropsStruct, MarketUtils.MarketPricesStruct, AddressLike, BigNumberish, AddressLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getSwapPriceImpact",
    values: [AddressLike, AddressLike, AddressLike, AddressLike, BigNumberish, Price.PropsStruct, Price.PropsStruct]
  ): string;
  encodeFunctionData(functionFragment: "getWithdrawal", values: [AddressLike, BytesLike]): string;
  encodeFunctionData(
    functionFragment: "getWithdrawalAmountOut",
    values: [AddressLike, Market.PropsStruct, MarketUtils.MarketPricesStruct, BigNumberish, AddressLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "isPositionLiquidatable",
    values: [AddressLike, AddressLike, BytesLike, Market.PropsStruct, MarketUtils.MarketPricesStruct, boolean, boolean]
  ): string;

  decodeFunctionResult(functionFragment: "getAccountOrders", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getAccountPositionInfoList", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getAccountPositions", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getAdlState", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getDeposit", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getDepositAmountOut", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getExecutionPrice", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getMarket", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getMarketBySalt", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getMarketInfo", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getMarketInfoList", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getMarketTokenPrice", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getMarkets", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getNetPnl", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getOpenInterestWithPnl", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getOrder", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getPendingPositionImpactPoolDistributionAmount", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getPnl", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getPnlToPoolFactor", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getPosition", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getPositionInfo", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getPositionInfoList", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getPositionPnlUsd", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getShift", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getSwapAmountOut", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getSwapPriceImpact", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getWithdrawal", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getWithdrawalAmountOut", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "isPositionLiquidatable", data: BytesLike): Result;
}

export interface SyntheticsReader extends BaseContract {
  connect(runner?: ContractRunner | null): SyntheticsReader;
  waitForDeployment(): Promise<this>;

  interface: SyntheticsReaderInterface;

  queryFilter<TCEvent extends TypedContractEvent>(
    event: TCEvent,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;
  queryFilter<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TypedEventLog<TCEvent>>>;

  on<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
  on<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  once<TCEvent extends TypedContractEvent>(event: TCEvent, listener: TypedListener<TCEvent>): Promise<this>;
  once<TCEvent extends TypedContractEvent>(
    filter: TypedDeferredTopicFilter<TCEvent>,
    listener: TypedListener<TCEvent>
  ): Promise<this>;

  listeners<TCEvent extends TypedContractEvent>(event: TCEvent): Promise<Array<TypedListener<TCEvent>>>;
  listeners(eventName?: string): Promise<Array<Listener>>;
  removeAllListeners<TCEvent extends TypedContractEvent>(event?: TCEvent): Promise<this>;

  getAccountOrders: TypedContractMethod<
    [dataStore: AddressLike, account: AddressLike, start: BigNumberish, end: BigNumberish],
    [ReaderUtils.OrderInfoStructOutput[]],
    "view"
  >;

  getAccountPositionInfoList: TypedContractMethod<
    [
      dataStore: AddressLike,
      referralStorage: AddressLike,
      account: AddressLike,
      markets: AddressLike[],
      marketPrices: MarketUtils.MarketPricesStruct[],
      uiFeeReceiver: AddressLike,
      start: BigNumberish,
      end: BigNumberish,
    ],
    [ReaderPositionUtils.PositionInfoStructOutput[]],
    "view"
  >;

  getAccountPositions: TypedContractMethod<
    [dataStore: AddressLike, account: AddressLike, start: BigNumberish, end: BigNumberish],
    [Position.PropsStructOutput[]],
    "view"
  >;

  getAdlState: TypedContractMethod<
    [dataStore: AddressLike, market: AddressLike, isLong: boolean, prices: MarketUtils.MarketPricesStruct],
    [[bigint, boolean, bigint, bigint]],
    "view"
  >;

  getDeposit: TypedContractMethod<[dataStore: AddressLike, key: BytesLike], [Deposit.PropsStructOutput], "view">;

  getDepositAmountOut: TypedContractMethod<
    [
      dataStore: AddressLike,
      market: Market.PropsStruct,
      prices: MarketUtils.MarketPricesStruct,
      longTokenAmount: BigNumberish,
      shortTokenAmount: BigNumberish,
      uiFeeReceiver: AddressLike,
      swapPricingType: BigNumberish,
      includeVirtualInventoryImpact: boolean,
    ],
    [bigint],
    "view"
  >;

  getExecutionPrice: TypedContractMethod<
    [
      dataStore: AddressLike,
      marketKey: AddressLike,
      prices: MarketUtils.MarketPricesStruct,
      positionSizeInUsd: BigNumberish,
      positionSizeInTokens: BigNumberish,
      sizeDeltaUsd: BigNumberish,
      pendingImpactAmount: BigNumberish,
      isLong: boolean,
    ],
    [ReaderPricingUtils.ExecutionPriceResultStructOutput],
    "view"
  >;

  getMarket: TypedContractMethod<[dataStore: AddressLike, key: AddressLike], [Market.PropsStructOutput], "view">;

  getMarketBySalt: TypedContractMethod<[dataStore: AddressLike, salt: BytesLike], [Market.PropsStructOutput], "view">;

  getMarketInfo: TypedContractMethod<
    [dataStore: AddressLike, prices: MarketUtils.MarketPricesStruct, marketKey: AddressLike],
    [ReaderUtils.MarketInfoStructOutput],
    "view"
  >;

  getMarketInfoList: TypedContractMethod<
    [
      dataStore: AddressLike,
      marketPricesList: MarketUtils.MarketPricesStruct[],
      start: BigNumberish,
      end: BigNumberish,
    ],
    [ReaderUtils.MarketInfoStructOutput[]],
    "view"
  >;

  getMarketTokenPrice: TypedContractMethod<
    [
      dataStore: AddressLike,
      market: Market.PropsStruct,
      indexTokenPrice: Price.PropsStruct,
      longTokenPrice: Price.PropsStruct,
      shortTokenPrice: Price.PropsStruct,
      pnlFactorType: BytesLike,
      maximize: boolean,
    ],
    [[bigint, MarketPoolValueInfo.PropsStructOutput]],
    "view"
  >;

  getMarkets: TypedContractMethod<
    [dataStore: AddressLike, start: BigNumberish, end: BigNumberish],
    [Market.PropsStructOutput[]],
    "view"
  >;

  getNetPnl: TypedContractMethod<
    [dataStore: AddressLike, market: Market.PropsStruct, indexTokenPrice: Price.PropsStruct, maximize: boolean],
    [bigint],
    "view"
  >;

  getOpenInterestWithPnl: TypedContractMethod<
    [
      dataStore: AddressLike,
      market: Market.PropsStruct,
      indexTokenPrice: Price.PropsStruct,
      isLong: boolean,
      maximize: boolean,
    ],
    [bigint],
    "view"
  >;

  getOrder: TypedContractMethod<[dataStore: AddressLike, key: BytesLike], [Order.PropsStructOutput], "view">;

  getPendingPositionImpactPoolDistributionAmount: TypedContractMethod<
    [dataStore: AddressLike, market: AddressLike],
    [[bigint, bigint]],
    "view"
  >;

  getPnl: TypedContractMethod<
    [
      dataStore: AddressLike,
      market: Market.PropsStruct,
      indexTokenPrice: Price.PropsStruct,
      isLong: boolean,
      maximize: boolean,
    ],
    [bigint],
    "view"
  >;

  getPnlToPoolFactor: TypedContractMethod<
    [
      dataStore: AddressLike,
      marketAddress: AddressLike,
      prices: MarketUtils.MarketPricesStruct,
      isLong: boolean,
      maximize: boolean,
    ],
    [bigint],
    "view"
  >;

  getPosition: TypedContractMethod<[dataStore: AddressLike, key: BytesLike], [Position.PropsStructOutput], "view">;

  getPositionInfo: TypedContractMethod<
    [
      dataStore: AddressLike,
      referralStorage: AddressLike,
      positionKey: BytesLike,
      prices: MarketUtils.MarketPricesStruct,
      sizeDeltaUsd: BigNumberish,
      uiFeeReceiver: AddressLike,
      usePositionSizeAsSizeDeltaUsd: boolean,
    ],
    [ReaderPositionUtils.PositionInfoStructOutput],
    "view"
  >;

  getPositionInfoList: TypedContractMethod<
    [
      dataStore: AddressLike,
      referralStorage: AddressLike,
      positionKeys: BytesLike[],
      prices: MarketUtils.MarketPricesStruct[],
      uiFeeReceiver: AddressLike,
    ],
    [ReaderPositionUtils.PositionInfoStructOutput[]],
    "view"
  >;

  getPositionPnlUsd: TypedContractMethod<
    [
      dataStore: AddressLike,
      market: Market.PropsStruct,
      prices: MarketUtils.MarketPricesStruct,
      positionKey: BytesLike,
      sizeDeltaUsd: BigNumberish,
    ],
    [[bigint, bigint, bigint]],
    "view"
  >;

  getShift: TypedContractMethod<[dataStore: AddressLike, key: BytesLike], [Shift.PropsStructOutput], "view">;

  getSwapAmountOut: TypedContractMethod<
    [
      dataStore: AddressLike,
      market: Market.PropsStruct,
      prices: MarketUtils.MarketPricesStruct,
      tokenIn: AddressLike,
      amountIn: BigNumberish,
      uiFeeReceiver: AddressLike,
    ],
    [
      [bigint, bigint, SwapPricingUtils.SwapFeesStructOutput] & {
        fees: SwapPricingUtils.SwapFeesStructOutput;
      },
    ],
    "view"
  >;

  getSwapPriceImpact: TypedContractMethod<
    [
      dataStore: AddressLike,
      marketKey: AddressLike,
      tokenIn: AddressLike,
      tokenOut: AddressLike,
      amountIn: BigNumberish,
      tokenInPrice: Price.PropsStruct,
      tokenOutPrice: Price.PropsStruct,
    ],
    [[bigint, bigint, bigint]],
    "view"
  >;

  getWithdrawal: TypedContractMethod<[dataStore: AddressLike, key: BytesLike], [Withdrawal.PropsStructOutput], "view">;

  getWithdrawalAmountOut: TypedContractMethod<
    [
      dataStore: AddressLike,
      market: Market.PropsStruct,
      prices: MarketUtils.MarketPricesStruct,
      marketTokenAmount: BigNumberish,
      uiFeeReceiver: AddressLike,
      swapPricingType: BigNumberish,
    ],
    [[bigint, bigint]],
    "view"
  >;

  isPositionLiquidatable: TypedContractMethod<
    [
      dataStore: AddressLike,
      referralStorage: AddressLike,
      positionKey: BytesLike,
      market: Market.PropsStruct,
      prices: MarketUtils.MarketPricesStruct,
      shouldValidateMinCollateralUsd: boolean,
      forLiquidation: boolean,
    ],
    [[boolean, string, PositionUtils.IsPositionLiquidatableInfoStructOutput]],
    "view"
  >;

  getFunction<T extends ContractMethod = ContractMethod>(key: string | FunctionFragment): T;

  getFunction(
    nameOrSignature: "getAccountOrders"
  ): TypedContractMethod<
    [dataStore: AddressLike, account: AddressLike, start: BigNumberish, end: BigNumberish],
    [ReaderUtils.OrderInfoStructOutput[]],
    "view"
  >;
  getFunction(
    nameOrSignature: "getAccountPositionInfoList"
  ): TypedContractMethod<
    [
      dataStore: AddressLike,
      referralStorage: AddressLike,
      account: AddressLike,
      markets: AddressLike[],
      marketPrices: MarketUtils.MarketPricesStruct[],
      uiFeeReceiver: AddressLike,
      start: BigNumberish,
      end: BigNumberish,
    ],
    [ReaderPositionUtils.PositionInfoStructOutput[]],
    "view"
  >;
  getFunction(
    nameOrSignature: "getAccountPositions"
  ): TypedContractMethod<
    [dataStore: AddressLike, account: AddressLike, start: BigNumberish, end: BigNumberish],
    [Position.PropsStructOutput[]],
    "view"
  >;
  getFunction(
    nameOrSignature: "getAdlState"
  ): TypedContractMethod<
    [dataStore: AddressLike, market: AddressLike, isLong: boolean, prices: MarketUtils.MarketPricesStruct],
    [[bigint, boolean, bigint, bigint]],
    "view"
  >;
  getFunction(
    nameOrSignature: "getDeposit"
  ): TypedContractMethod<[dataStore: AddressLike, key: BytesLike], [Deposit.PropsStructOutput], "view">;
  getFunction(
    nameOrSignature: "getDepositAmountOut"
  ): TypedContractMethod<
    [
      dataStore: AddressLike,
      market: Market.PropsStruct,
      prices: MarketUtils.MarketPricesStruct,
      longTokenAmount: BigNumberish,
      shortTokenAmount: BigNumberish,
      uiFeeReceiver: AddressLike,
      swapPricingType: BigNumberish,
      includeVirtualInventoryImpact: boolean,
    ],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "getExecutionPrice"
  ): TypedContractMethod<
    [
      dataStore: AddressLike,
      marketKey: AddressLike,
      prices: MarketUtils.MarketPricesStruct,
      positionSizeInUsd: BigNumberish,
      positionSizeInTokens: BigNumberish,
      sizeDeltaUsd: BigNumberish,
      pendingImpactAmount: BigNumberish,
      isLong: boolean,
    ],
    [ReaderPricingUtils.ExecutionPriceResultStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getMarket"
  ): TypedContractMethod<[dataStore: AddressLike, key: AddressLike], [Market.PropsStructOutput], "view">;
  getFunction(
    nameOrSignature: "getMarketBySalt"
  ): TypedContractMethod<[dataStore: AddressLike, salt: BytesLike], [Market.PropsStructOutput], "view">;
  getFunction(
    nameOrSignature: "getMarketInfo"
  ): TypedContractMethod<
    [dataStore: AddressLike, prices: MarketUtils.MarketPricesStruct, marketKey: AddressLike],
    [ReaderUtils.MarketInfoStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getMarketInfoList"
  ): TypedContractMethod<
    [
      dataStore: AddressLike,
      marketPricesList: MarketUtils.MarketPricesStruct[],
      start: BigNumberish,
      end: BigNumberish,
    ],
    [ReaderUtils.MarketInfoStructOutput[]],
    "view"
  >;
  getFunction(
    nameOrSignature: "getMarketTokenPrice"
  ): TypedContractMethod<
    [
      dataStore: AddressLike,
      market: Market.PropsStruct,
      indexTokenPrice: Price.PropsStruct,
      longTokenPrice: Price.PropsStruct,
      shortTokenPrice: Price.PropsStruct,
      pnlFactorType: BytesLike,
      maximize: boolean,
    ],
    [[bigint, MarketPoolValueInfo.PropsStructOutput]],
    "view"
  >;
  getFunction(
    nameOrSignature: "getMarkets"
  ): TypedContractMethod<
    [dataStore: AddressLike, start: BigNumberish, end: BigNumberish],
    [Market.PropsStructOutput[]],
    "view"
  >;
  getFunction(
    nameOrSignature: "getNetPnl"
  ): TypedContractMethod<
    [dataStore: AddressLike, market: Market.PropsStruct, indexTokenPrice: Price.PropsStruct, maximize: boolean],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "getOpenInterestWithPnl"
  ): TypedContractMethod<
    [
      dataStore: AddressLike,
      market: Market.PropsStruct,
      indexTokenPrice: Price.PropsStruct,
      isLong: boolean,
      maximize: boolean,
    ],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "getOrder"
  ): TypedContractMethod<[dataStore: AddressLike, key: BytesLike], [Order.PropsStructOutput], "view">;
  getFunction(
    nameOrSignature: "getPendingPositionImpactPoolDistributionAmount"
  ): TypedContractMethod<[dataStore: AddressLike, market: AddressLike], [[bigint, bigint]], "view">;
  getFunction(
    nameOrSignature: "getPnl"
  ): TypedContractMethod<
    [
      dataStore: AddressLike,
      market: Market.PropsStruct,
      indexTokenPrice: Price.PropsStruct,
      isLong: boolean,
      maximize: boolean,
    ],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "getPnlToPoolFactor"
  ): TypedContractMethod<
    [
      dataStore: AddressLike,
      marketAddress: AddressLike,
      prices: MarketUtils.MarketPricesStruct,
      isLong: boolean,
      maximize: boolean,
    ],
    [bigint],
    "view"
  >;
  getFunction(
    nameOrSignature: "getPosition"
  ): TypedContractMethod<[dataStore: AddressLike, key: BytesLike], [Position.PropsStructOutput], "view">;
  getFunction(
    nameOrSignature: "getPositionInfo"
  ): TypedContractMethod<
    [
      dataStore: AddressLike,
      referralStorage: AddressLike,
      positionKey: BytesLike,
      prices: MarketUtils.MarketPricesStruct,
      sizeDeltaUsd: BigNumberish,
      uiFeeReceiver: AddressLike,
      usePositionSizeAsSizeDeltaUsd: boolean,
    ],
    [ReaderPositionUtils.PositionInfoStructOutput],
    "view"
  >;
  getFunction(
    nameOrSignature: "getPositionInfoList"
  ): TypedContractMethod<
    [
      dataStore: AddressLike,
      referralStorage: AddressLike,
      positionKeys: BytesLike[],
      prices: MarketUtils.MarketPricesStruct[],
      uiFeeReceiver: AddressLike,
    ],
    [ReaderPositionUtils.PositionInfoStructOutput[]],
    "view"
  >;
  getFunction(
    nameOrSignature: "getPositionPnlUsd"
  ): TypedContractMethod<
    [
      dataStore: AddressLike,
      market: Market.PropsStruct,
      prices: MarketUtils.MarketPricesStruct,
      positionKey: BytesLike,
      sizeDeltaUsd: BigNumberish,
    ],
    [[bigint, bigint, bigint]],
    "view"
  >;
  getFunction(
    nameOrSignature: "getShift"
  ): TypedContractMethod<[dataStore: AddressLike, key: BytesLike], [Shift.PropsStructOutput], "view">;
  getFunction(nameOrSignature: "getSwapAmountOut"): TypedContractMethod<
    [
      dataStore: AddressLike,
      market: Market.PropsStruct,
      prices: MarketUtils.MarketPricesStruct,
      tokenIn: AddressLike,
      amountIn: BigNumberish,
      uiFeeReceiver: AddressLike,
    ],
    [
      [bigint, bigint, SwapPricingUtils.SwapFeesStructOutput] & {
        fees: SwapPricingUtils.SwapFeesStructOutput;
      },
    ],
    "view"
  >;
  getFunction(
    nameOrSignature: "getSwapPriceImpact"
  ): TypedContractMethod<
    [
      dataStore: AddressLike,
      marketKey: AddressLike,
      tokenIn: AddressLike,
      tokenOut: AddressLike,
      amountIn: BigNumberish,
      tokenInPrice: Price.PropsStruct,
      tokenOutPrice: Price.PropsStruct,
    ],
    [[bigint, bigint, bigint]],
    "view"
  >;
  getFunction(
    nameOrSignature: "getWithdrawal"
  ): TypedContractMethod<[dataStore: AddressLike, key: BytesLike], [Withdrawal.PropsStructOutput], "view">;
  getFunction(
    nameOrSignature: "getWithdrawalAmountOut"
  ): TypedContractMethod<
    [
      dataStore: AddressLike,
      market: Market.PropsStruct,
      prices: MarketUtils.MarketPricesStruct,
      marketTokenAmount: BigNumberish,
      uiFeeReceiver: AddressLike,
      swapPricingType: BigNumberish,
    ],
    [[bigint, bigint]],
    "view"
  >;
  getFunction(
    nameOrSignature: "isPositionLiquidatable"
  ): TypedContractMethod<
    [
      dataStore: AddressLike,
      referralStorage: AddressLike,
      positionKey: BytesLike,
      market: Market.PropsStruct,
      prices: MarketUtils.MarketPricesStruct,
      shouldValidateMinCollateralUsd: boolean,
      forLiquidation: boolean,
    ],
    [[boolean, string, PositionUtils.IsPositionLiquidatableInfoStructOutput]],
    "view"
  >;

  filters: {};
}
